\documentclass{scrartcl}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{booktabs, array}
\usepackage{tikz, environ}
\usepackage{pgffor, fp}
\usepackage{hyperref}
\usepackage[normalem]{ulem}

%%%%%%%%%
% SETUP %
%%%%%%%%%

\usetikzlibrary{decorations.pathreplacing, calligraphy, arrows.meta}

\DeclareMathOperator{\op}{op}
\DeclareMathOperator{\instr}{instr}

\makeatletter
\newsavebox{\measure@tikzpicture}
\NewEnviron{scalepicture}[1]{%
  \def\tikz@width{#1}%
  \def\tikzscale{1}\begin{lrbox}{\measure@tikzpicture}%
  \BODY
  \end{lrbox}%
  \pgfmathparse{#1/\wd\measure@tikzpicture}%
  \edef\tikzscale{\pgfmathresult}%
  \BODY
}
\makeatother

%%%%%%%%%%%%
% DOCUMENT %
%%%%%%%%%%%%

\title{Rapport}
\author{%
  Jean \textsc{Caspar},
  Lo√Øc \textsc{Chevalier},\\
  Vladimir \textsc{Ivanov},
  Adrien \textsc{Mathieu}
}
\date{}

\begin{document}
\maketitle{}
\section*{Hardware specification}
The CPU provides 16 accessible registers, \(r_0,\ldots,r_{15}\), as
well as an instruction pointer \(ip\), a RAM and IO ports. A machine
word is 16 bits. If an operation requires writing and reading at the
same place, the value read is the one \emph{before} the write takes
place. Every storage unit is initially initialized with \(0\).\par
In particular, the CPU does \emph{not} contain any flag that is
implicitly set during any operation.
\subsection*{Registers}
Among the 16 registers, fifteen are general purpose registers, and
one is a zero register. More specifically, the first register \(r_0\)
can be used as the destination of an operation, in which case the result
of the aforementioned operation is ignored. It can also be used as a
source register, in which can it acts as the constant \(0\).\par
All the other registers are general purpose 16 bit registers, which
can be accessed both for writing and for reading, even in a single
cycle.
\subsection*{RAM}
The size of the RAM is left unspecified. Reading and writing from and
to the RAM is done a single machine-word at a time.
\subsection*{Instruction Pointer}
The instruction pointer has the same size as a general purpose
register. It is initialized with the value \(0\). It cannot be
accessed directly. It can be written to, but cannot be read from.

\section*{Instructions}
An instruction is 32 bits wide. The first eight bits encode the
instruction code, the 24 remaining bits contain the arguments. See
the figure \nameref{fig:instrs} and the table \nameref{tab:instrs}.
\subsection*{Instruction code}
The first bit of an instruction code corresponds to the arity of the
instruction.
A $0$ means an arity of one, a $1$ means an arity of two. Every
instruction additionally receives a \emph{destination register} $r_d$,
in which the result of the operation must be stored, unless told
otherwise.\par
The next five bits encode to the operation. The first two bits indicate
the operation family:
\begin{itemize}
\item $00$: Arithmetic and logic operation.
\item $01$: Jump operation.
\item $10$: RAM operation
\item $11$: Comparison operation.
\end{itemize}
The next three bits specify the actual operation performed.\par
The two final bits of the instruction code indicate whether arguments are
registers or immediates, $1$ meaning register and $0$ immediate. The first of
these two bits corresponds to $a_1$, whereas the second to $a_2$.
\subsection*{Arguments}
Arguments are of two kind: immediates and registers. Registers require four bits,
whereas immediates are 16 bits signed integers. At most one immediate can be
given.\par
The first ``argument'' is always a register, $r_d$. The next argument $a_1$, or
the next two arguments $a_1$ and $a_2$, in this order, can be registers or
immediates.

\section*{Implementation details}
\subsection*{Miscellaneous operations}
\verb|load| and \verb|store|, as well as \verb|recv| and \verb|send|, are encoded
in the same way, except for the arity. This allows merging them into a single
operation, with the arity feeding the \verb|we| flag of the RAM/port and register
file modules.
\subsection*{Comparison operation}
The comparison operation's last three bits encode the actual comparison being made.
The first bit indicates the negation of the result, the second indicates whether
the arguments are considered as signed, the last number indicates whether we
apply less than.

\section*{Assembly}
The assembly's syntax is very close to common other common assembly
languages. Destination registers (ie. registers that are written to)
are specified in a binding form: \(r_d = \textrm{op } a_1, a_2\).\par
Comments are introduced with semicolons. Each line holds a single
operation, a label, or nothing at all.

\subsection*{Labels}
Two kind of labels are supported: named labels, and relative labels.\par
Named labels should have unique names (ie. names that are not used
by any other labels). Any operation can jump to a named label simply
by giving its name instead of an explicit address.\par
Relative labels are labels whose name is a natural number. They need
not to be unique, and can be referenced by giving their number
followed by a single character indicating if the \emph{next} such label
or if the \emph{previous} such label is considered. For instance,
\(1f\) indicates the next label called \(1\), whereas \(12b\) indicates
the previous label called \(12\).

\subsection*{Immediates}
At most one immediate can be present per instruction. An immediate
must fit into a signed 16 bit number. Any arithmetic operation that
fits into 16 bit arithmetic will be resolved at assembling-time
(ie. \(2^{16}-2^{16}\) will fail, even though the result could fit in
a 16-bit signed integer). Subtracting two labels is considered a valid
arithmetic operation, and results in the number of instructions
that will be issued between the two labels.

\subsection*{Syntactic sugar}
The assembler provided with the CPU (\verb|asj|), which complies with
the given specification, has some syntactic sugar.\par
Binding move-like operations are supported (ie. \(r5 = 15\)), by
transforming them into additions with \(r0\) (ie. the example becomes
\(r5 = add 15, r0\)).\par
\(\mathrm{RAM}\) can be used as a C-like array: it can be accessed
in an expression (\(r5 = \mathrm{RAM}[r4]\)) and written to similarly
(\(\mathrm{RAM}[r4] = r5\)). This will be converted to the
corresponding \verb|load|/\verb|store| operations.\par
Similarly, \(\textrm{port }x\) can be used as the \(x\)-th port of
the IO ports provided. This will be translated to the corresponding
\verb|send| / \verb|recv| operations. Note that it will not be the
same ports if used in a write manner or in a read manner, since they
physically correspond to different pins.

\section*{Simulation}
The CPU targets FPGAs, but can be simulated both in real-time and as
fast as possible. For the latter, a version of the clock program
which never waits is also provided. To this end, the CPU source code
is divided into a synthetisable part, and a standalone simulatable
part. The simulatable part adds features that should otherwise be
provided by the hardware, such as a clock, the ROM and IO operations.\par
Due to Verilog lacking some simulation features, an ``extension'' of
the language has been \sout{horrendously glued together} elegantly
added to the core features of Verilog. These features can be used from
within Verilog by printing a command, and reading a character from
stdin. A simulation wrapper is then responsible from filtering the
stdout of the simulation process, acknowledging and processing the
external commands, and feeding back a character when the whole
operation is over.\par
The simulation wrapper also takes care of simulating buttons and
displays in an interactive, real-time way.
\subsection*{Real-time wait}
The extension to Verilog includes providing a real-time wait
instruction, similarly to how a hardware clock would provide real-time
heartbeats.

\subsection*{Interactive IO}
The extension to Verilog also includes an interface for communicating
with the CPU that does not rely on the user manually setting and reading each
pin's value, but instead simulates buttons as they would behave on an
FPGA, and shows the values that would normally be displayed on seven
segment displays.

\section*{Virtualization}
A virtual machine targeting the defined architecture is also provided.
It can be used to run programs assembled with the given assembler
without running them on the CPU, which may be useful for debugging purposes
as it allows to display the internal state of the CPU; therefore, if a
program is not working as intended, we can check if it does what it is
supposed to do using the VM, so we know what to fix (the program or the
CPU).\par
The core VM is also extendable to support multiple output (I/O) formats.
The default VM does not update any input nor any output, but a \verb+clock+
version of it displays on the terminal the time as required by the program
(the seconds on port 0, ..., the year on port 5, and two buttons are mapped
to ports 0 and 1).

\section*{Clock program}

The clock program works in two distinct phases: first, the program waits for
the user to input the current time, using busy loops to wait for button
presses and releases. Once the current time is set and confirmed, the program
goes into its second mode: a 32-bits wide "register" (\verb+r9:r1+) is
incremented by the number of clock cycles it takes to execute a block of
code, before executing the block of code.\par
The first loop is a simple incrementer of the two-registers counters. Once
they reach a certain value ($\verb+r9:r1+ \geq 12 \cdot 10^6$ as the FPGA has
a clock that runs at this speed, and is the clock used), the number of
seconds is incremented by one, then sent, then it is checked against its
maximum value of $60$. If it is not, the program jumps back to the first
loop. If it is, it is reset, sent again, then the minutes are
incremented...
To speed up the rolling process, the number of days in the current month, the
number of days in February of the current year, the number of years until a
multiple of 4 years (excluding the current year), the number of 4-years until
a multiple of 100 years (excluding the current year) and the number of
100-years until a multiple of 400 years are all stored in registers
\verb+r11+ through \verb+r15+ (not in that order).

\section{Porting the CPU to an FPGA.}

We ported the CPU to the Arty S7 FPGA. It runs at 12MHz and the clock, when running at maximum frequency, counts one month in about one second.

We have 6 output displays, on which the date and time are displayed in either HH/MM/SS, YY/MM/DD, or YYYY/MM format. We have three slide switches to select between those formats, a reset button, and a slideswitch that disables waiting for one second between updates, thus making the clock run really fast. We read the input with two buttons.

Remembering the CPU's outputs, converting binary to BCD and then to 7 segment display activations, and selecting whether to display HH/MM/SS, YY/MM/DD, or YYYY/MM, is done with the SystemVerilog code in \verb|cpu_FPGA.sv|.

Our main problem was I/O. The FPGA does only have enough output pins for six 7 segment displays, and we did not find an easy way to make it interface with a computer while running.
Our first attempt was to solder a deserializer, but it was unsuccessful.
We then switched to the idea of having the user select which digits are displayed.
We were starting with the assumption that the interface of any deserializer or display we could buy would be too complicated to realistically make it work with the FPGA.

Another difficulty was the Vivado IDE's two minute compile time and the FPGA's lack of an easy to use logging interface, making debugging hard.

A few insignificant parts of the SystemVerilog code had to be modified in order for it to become synthetisable. A non-synthesizable part of the code had to be rewritten in order for it to work (we had timing issues otherwise).

\begin{figure}[b]
  \label{fig:instrs}
  \begin{scalepicture}{\textwidth}
    \begin{tikzpicture}[
      thick,
      scale=\tikzscale,
      brace/.style={
        decorate,
        decoration={
          calligraphic brace,
          raise=2pt,
          amplitude=10pt,
        },
      }
      ]

      \draw[brace] (0,2) -- (24,2);
      \draw[brace] (24,2) -- (32,2);
      \node at (28,3.5) {instruction code};
      \node at (12,3.5) {arguments};

      %% 0, 1X
      
      \foreach \n in {0,...,31}{
        \FPeval{\next}{clip(\n+1)}
        \FPeval{\lab}{clip(31-\n)}
        \draw (\n,0) rectangle (\next,1);
        \node at (\n.5,1.5) {$\lab$};
      }
      \foreach \n in {16, 20, 24, 26, 31, 32}{
        \draw[dotted] (\n,0) -- (\n,-1);
      }
      \node at (28.5,-.5) {operation};
      \node at (22,-.5) {$r_d$};
      
      \node at (31.5,.5) {$0$};
      \node at (25.5,.5) {$1$};
      \node at (24.5,.5) {X};
      \node at (18,-.5) {$r_1$};
      \foreach \n in {0,...,15}{
        \node at (\n.5,.5) {X};
      }

      %% 0, 0X
      \foreach \n in {0,...,31}{
        \FPeval{\next}{clip(\n+1)}
        \draw (\n,-2) rectangle (\next,-1);
      }
      \foreach \n in {32,31,26,24,20,4}{
      % \foreach \n in {0,1,6,8,12,28}{
        \draw[dotted] (\n,-3) -- (\n,-2);
      }
      \node at (28.5,-2.5) {operation};
      \node at (22,-2.5) {$r_d$};
      \node at (31.5,-1.5) {$0$};
      
      \node at (25.5,-1.5) {$0$};
      \node at (24.5,-1.5) {X};
      \node at (12,-2.5) {$i$};
      \foreach \n in {0,...,3}{
        \node at (\n.5,-1.5) {X};
      }

      %% 1, 11
      \foreach \n in {0,...,31}{
        \FPeval{\next}{clip(\n+1)}
        \draw (\n,-4) rectangle (\next,-3);
      }
      \foreach \n in {32,31,26,24,20,16,4}{
        \draw[dotted] (\n,-5) -- (\n,-4);
      }
      \node at (28.5,-4.5) {operation};
      \node at (22,-4.5) {$r_d$};
      \node at (31.5,-3.5) {$1$};
      
      \node at (25.5,-3.5) {$1$};
      \node at (24.5,-3.5) {$1$};
      \node at (18,-4.5) {$r_1$};
      \node at (2,-4.5) {$r_2$};
      \foreach \n in {4,...,15}{
        \node at (\n.5,-3.5) {X};
      }

      %% 1, 10
      \foreach \n in {0,...,31}{
        \FPeval{\next}{clip(\n+1)}
        \draw (\n,-6) rectangle (\next,-5);
      }
      \foreach \n in {32,31,26,24,20,16,0}{
        \draw[dotted] (\n,-7) -- (\n,-6);
      }
      \node at (28.5,-6.5) {operation};
      \node at (22,-6.5) {$r_d$};
      \node at (31.5,-5.5) {$1$};
      
      \node at (25.5,-5.5) {$1$};
      \node at (24.5,-5.5) {$0$};
      \node at (18,-6.5) {$r_1$};
      \node at (8,-6.5) {$i$};

      %% 1, 01
      \foreach \n in {0,...,31}{
        \FPeval{\next}{clip(\n+1)}
        \draw (\n,-8) rectangle (\next,-7);
      }
      \foreach \n in {32,31,26,24,20,4,0}{
        \draw[dotted] (\n,-9) -- (\n,-8);
      }
      \node at (28.5,-8.5) {operation};
      \node at (22,-8.5) {$r_d$};
      \node at (31.5,-7.5) {$1$};
      
      \node at (25.5,-7.5) {$0$};
      \node at (24.5,-7.5) {$1$};
      \node at (12,-8.5) {$i$};
      \node at (2,-8.5) {$r_2$};
    \end{tikzpicture}
  \end{scalepicture}
  \caption{Layout of instructions}
\end{figure}

\begin{table}
  \center
  \label{tab:instrs}
  \caption{Layout of instructions}
  \begin{tabular}{lcc}
    \toprule
    \textbf{Bits used} & \textbf{value} & \textbf{size}\\
    \midrule
    \multicolumn{3}{c}{\(r_d = \op(r_1)\)}\\
    \(\instr[0:0]\) & \(0\) & 1 bit\\
    \(\instr[5:1]\) & \(\op\) & 5 bits\\
    \(\instr[6:6]\) & \(1\) & 1 bit\\
    \(\instr[11:8]\) & \(r_d\) & 4 bits\\
    \(\instr[15:12]\) & \(r_1\) & 4 bits\\
    \midrule
    \multicolumn{3}{c}{\(r_d = \op(i)\)}\\
    \(\instr[0:0]\) & \(0\) & 1 bit\\
    \(\instr[5:1]\) & \(\op\) & 5 bits\\
    \(\instr[6:6]\) & \(0\) & 1 bit\\
    \(\instr[11:8]\) & \(r_d\) & 4 bits\\
    \(\instr[27:12]\) & \(i\) & 16 bits\\
    \midrule
    \multicolumn{3}{c}{\(r_d = \op(r_1, r_2)\)}\\
    \(\instr[0:0]\) & \(1\) & 1 bit\\
    \(\instr[5:1]\) & \(\op\) & 5 bits\\
    \(\instr[7:6]\) & \(11\) & 2 bits\\
    \(\instr[11:8]\) & \(r_d\) & 4 bits\\
    \(\instr[15:12]\) & \(r_1\) & 4 bits\\
    \(\instr[31:28]\) & \(r_2\) & 4 bits\\
    \midrule
    \multicolumn{3}{c}{\(r_d = \op(i, r_2)\)}\\
    \(\instr[0:0]\) & \(1\) & 1 bits\\
    \(\instr[5:1]\) & \(\op\) & 5 bits\\
    \(\instr[7:6]\) & \(01\) & 2 bits\\
    \(\instr[11:8]\) & \(r_d\) & 4 bits\\
    \(\instr[27:12]\) & \(i\) & 16 bits\\
    \(\instr[31:28]\) & \(r_2\) & 4 bits\\
    \midrule
    \multicolumn{3}{c}{\(r_d = \op(r_1, i)\)}\\
    \(\instr[0:0]\) & \(1\) & 1 bit\\
    \(\instr[5:1]\) & \(\op\) & 5 bits\\
    \(\instr[7:6]\) & \(10\) & 2 bits\\
    \(\instr[11:8]\) & \(r_d\) & 4 bits\\
    \(\instr[15:12]\) & \(r_1\) & 4 bits\\
    \(\instr[31:16]\) & \(i\) & 16 bits\\
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}
  \caption{Operation list}

  \begin{tabular}{lcrl}
    \toprule
    \textbf{Name} & \textbf{Arity} & \textbf{Encoding} & \textbf{Effect}\\
    \midrule
    \midrule
    \multicolumn{3}{c}{Arithmetic and logic operation}\\
    \midrule
    add & 2 & \(00\;000\) & \(r_d=a_1+a_2\)\\
    sub & 2 & \(00\;001\) & \(r_d=a_1-a_2\)\\
    mul & 2 & \(00\;010\) & \(r_d=a_1\cdot a_2\)\\
    div & 2 & \(00\;011\) & \(r_d=a_1/a_2\)\\
    mod & 2 & \(00\;100\) & \(r_d=a_1\% a_2\)\\
    and & 2 & \(00\;101\) & \(r_d=a_1 \& a_2\)\\
    or & 2 & \(00\;110\) & \(r_d=a_1 | a_2\)\\
    xor & 2 & \(00\;111\) & \(r_d=a_1\bigoplus a_2\)\\
    \midrule
    \multicolumn{3}{c}{Jump operation}\\
    \midrule
    jmp & 1 & \(01\;000\) & \(ip=a_1\)\\
    jo & 1 & \(01\;001\) & \(ip=ip+a_1\)\\
    jz & 2 & \(01\;000\) & if \(a_2=0\), \(ip=a_1\)\\
    jzo & 2 & \(01\;001\) & if \(a_2=0\), \(ip=ip+a_1\)\\
    jnz & 2 & \(01\;010\) & if \(a_2\neq0\), \(ip=a_1\)\\
    jnzo & 2 & \(01\;011\) & if \(a_2\neq0\), \(ip=ip+a_1\)\\
    \midrule
    \multicolumn{3}{c}{Comparison operation}\\
    \midrule
    cmp\textit{cc} & 2 & \(11\;???\) & if \(a_1\;cc\;a_2\), \(r_d=1\),\\
                  &  &  & otherwise \(r_d=0\)\\
    \midrule
    \multicolumn{3}{c}{Miscellaneous}\\
    \midrule
    load & 1 & \(10\;000\) & \(r_d=\mathrm{RAM}[a_1]\)\\
    store & 2 & \(10\;000\) & \(\mathrm{RAM}[a_1]=a_2\)\\
    recv & 1 & \(10\;001\) & \(r_d=\mathrm{port}~a_1\)\\
    send & 2 & \(10\;001\) & \(\mathrm{port}~a_1=a_2\)\\
    \bottomrule
  \end{tabular}
  \quad
  \begin{tabular}{lc}
    \multicolumn{2}{c}{\(cc\) encoding}\\
    \toprule
    \textbf{Name} & \textbf{Encoding}\\
    \midrule
    eq & \(000\)\\
    ne & \(100\)\\
    bl & \(001\)\\
    ae & \(101\)\\
    lt & \(011\)\\
    ge & \(111\)\\
    \bottomrule
  \end{tabular}

\end{table}
\end{document}
