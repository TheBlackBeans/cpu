\documentclass{beamer}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{microtype}
\usepackage{url, hyperref}
\usepackage{graphicx}
\usepackage{emoji}
\usepackage{tikz}
\usepackage{pgffor, fp}

\usetikzlibrary{decorations.pathreplacing, calligraphy, arrows.meta}

\usetheme{Dresden}

\setbeamertemplate{navigation symbols}{}

\definecolor{purple}{rgb}{0.5, 0, 1}
\setbeamercolor*{palette primary}{use=structure, fg=white, bg=purple}
\setbeamercolor*{palette secondary}{use=structure, fg=white, bg=purple}
\setbeamercolor*{palette tertiary}{use=structure, fg=white, bg=purple}
\setbeamercolor*{palette quaternary}{use=structure, fg=white, bg=purple}

\setbeamercolor*{sidebar}{fg=purple,bg=gray!15!white}

\setbeamercolor*{palette sidebar primary}{fg=purple!10!black}
\setbeamercolor*{palette sidebar secondary}{fg=white}
\setbeamercolor*{palette sidebar tertiary}{fg=purple!50!black}
\setbeamercolor*{palette sidebar quaternary}{fg=gray!10!white}

\setbeamercolor{titlelike}{parent=palette primary,bg=purple}
\setbeamercolor{frametitle}{bg=yellow!90!white, fg=purple}
\setbeamercolor{frametitle right}{bg=gray!60!white}

\title{CPU et horloge sur FPGA}
\author[%
J. \textsc{Caspar},
L. \textsc{Chevalier},
V. \textsc{Ivanov},
A. \textsc{Mathieu}%
]{
  Jean \textsc{Caspar},
  Loïc \textsc{Chevalier},
  Vladimir \textsc{Ivanov},
  Adrien \textsc{Mathieu}
}
\date{24 Janvier 2023}

\begin{document}

\begin{frame}[noframenumbering]
  \titlepage
\end{frame}

\begin{frame}[fragile]{Jeu d'instructions}
  L'instruction set de notre CPU est \emph{très vaguement} inspiré de
  RISC-V. Chaque instruction peut prendre un ou deux arguments, et
  éventuellement spécifier un registre où stocker le résultat.\par
  \pause
  16 registres 16-bit sont disponibles. Le premier, \(r_0\), vaut
  toujours \(0\).\par
  \pause
  % \vspace
  \begin{tikzpicture}[
    thick,
    scale=.36,
    brace/.style={
      decorate,
      decoration={
        calligraphic brace,
        raise=2pt,
        amplitude=10pt,
      },
    },
    ]
    % \draw[brace] (0,2) -- (24,2);
    % \draw[brace] (24,2) -- (32,2);

    \foreach \n in {0,...,31}{
      \FPeval{\next}{clip(\n+1)}
      \FPeval{\lab}{clip(31-\n)}
      \draw (\n,0) rectangle (\next,1);
      \node[scale=.8] at (\n.5,1.5) {$\lab$};
    }
    \foreach \n in {0, 4, 16, 20, 24, 26, 31, 32}{
      \draw[dotted] (\n,0) -- (\n,-1);
    }
    \node[scale=.8] at (28.5,-.5) {opération};
    \node[scale=.8,rotate=90] at (31.5,-.9) {arité};
    \node[scale=.8,rotate=90] at (25.5,-2) {\(a_1\) registre};
    \node[scale=.8,rotate=90] at (24.5,-2) {\(a_2\) registre};
    \node[scale=.8] at (22,-.5) {\(r_d\)};
    \node[scale=.8] at (18,-.5) {\(r_1\)};
    \node[scale=.8] at (2,-.5) {\(r_2\)};
    \draw[brace, decoration={mirror}] (0,-1) -- (16,-1);
    \draw[brace, decoration={mirror}] (4,-1.15) -- (20,-1.15);
    \node[scale=.8] at (8,-2.6) {$i$};
    \node[scale=.8] at (12,-2.75) {$i$};
  \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Familles d'instructions}
  Les instructions disponibles se divisent en quatre familles\pause
  \begin{itemize}
  \item Les opérations arithmétiques et logiques. Celles-ci incluent
    la division et le modulo, mais ne sont pas utilisées dans notre
    programme.
    \pause
  \item Les opérations de comparaison. Elles se déclinent en opérations
    signées et non-signées. Toutes les opérations ne sont pas
    disponibles (manque de place).
    \pause
  \item Les opérations de saut. Les sauts relatifs sont supportés, mais
    jamais utilisés.
    \pause
  \item Les opérations externes à la CPU. Cela correspond à la RAM et
    aux ports d'IO.
  \end{itemize}
\end{frame}

\begin{frame}{Assembleur}
  Un assembleur\footnote{\emoji{crab}} est fourni avec la CPU. En plus
  de simplement assembler, il permet quelques facilités, qui ne sont
  que du sucre syntaxique.\par
  \pause
  Par exemple, toutes les opérations de comparaison sont disponibles
  dans l'assembly; elles sont ensuite exprimées en fonction de celles
  disponibles.\par
  \pause
  De même, la RAM et les ports d'IO peuvent être utilisés comme un
  tableau en C, et les expressions arithmétiques sont résolues au
  moment de la compilation en un immédiat unique.
\end{frame}

\begin{frame}{VM}
  \begin{itemize}
  \item VM qui simule les opérations du CPU.
    \pause
  \item Peut prendre en paramètre la fréquence à laquelle simuler,
    l'état des registres (y compris l'adresse de l'instruction
    courante).
    \pause
  \item Peut afficher l'état interne du CPU virtuel à chaque cycle
    \pause
  \item Gestion des I/O séparée du c\oe{}ur de la VM: programmes de
    tests sans entrée/sortie contre programme de l'horloge avec des
    entrées/sorties spécifiques.
  \end{itemize}
\end{frame}

\begin{frame}{Simulateur}
  \begin{itemize}
  \item Simule le CPU physique.
    \pause
  \item Par défaut, exécute aussi vite que possible; wrapper Python
    autour ainsi qu'une légère modification du code du CPU non
    synthétisable pour forcer l'horloge à être à la fréquence attendue.
    \pause
  \item Dernière étape avant le téléchargement sur le FPGA.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Programme}
  \begin{itemize}
  \item Horloge: de secondes à année
    \pause
  \item Deux phases:
    \begin{enumerate}
    \item initialisation, déplacement entre des boucles selon les
      entrées de l'utilisateur
    \item boucle principale, deux registres utilisés pour retenir le
      nombre de cycles écoulés ($12 \cdot 10^6 = 183 \cdot 2^{16} + 6912$).
      \pause
    \end{enumerate}

  \item Gestion des jours: utilisation d'un registre pour ne pas
    recalculer le dernier jour du mois tous les jours (seulement tous
    les mois)
    \pause
  \item Gestion des années bissextiles: utilisation de 3 registres
    pour repérer quelle année modulo 400 on est sans utiliser de
    division ou de modulo, utilisation d'un registre pour mémoriser
    cette information (en fait \verb+r11+ retient le nombre de jour au
    mois de février).
  \end{itemize}
\end{frame}

\begin{frame}{Verilog}
  Le programme Verilog est séparé en plusieurs modules.
  \pause
  \begin{itemize}
  \item ALU et comparateur
    \pause
  \item Un pointeur d'instruction, et un module pour gérer les sauts
    \pause
  \item Des registres, de la RAM et un sélecteur d'instruction
    \pause
  \item Des bus et un module de gestion de l'IO
    \pause
  \item Un driver qui instancie les autres modules
  \end{itemize}
\end{frame}

\begin{frame}{FPGA}
  Précédemment nous avions tenté d'utiliser 12 afficheurs 7 segments
  pour tout afficher en même temps. Mais le FPGA n'a pas autant de
  sorties donc il aurait fallu utiliser des puces en plus pour servir
  de registres et de décodeur.
  \begin{center}
    \includegraphics[scale=0.05]{pictures/Soudure global.jpg}
  \end{center}
\end{frame}

\begin{frame}{Échec critique}
  C'est un échec:
  \begin{center}
    \includegraphics[scale=0.07]{pictures/Soudure proche.jpg}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  Nous sommes mauvais en soudure, et il y avait trop de court-circuits,
  donc nous avons abandonné.\par
  Finalement, nous avons utilisé une breadboard (pas besoin de
  soudures) et seulement 6 afficheurs, on peut changer de mode
  d'affichage avec les boutons. Nous pouvons afficher \verb|HH/MM/SS|,
  \verb|YY/MO/DD| ou \verb|YYYY/MO|.
  \begin{center}
    \includegraphics[angle=90,scale=0.04]{pictures/FPGA final.jpg}
  \end{center}
\end{frame}
\begin{frame}{Conclusion}
  Notre CPU tourne, avec le programme horloge, à \(12\mathrm{MHz}\).\par
  Cela correspond à peu près à un mois par seconde.
\end{frame}

\end{document}
